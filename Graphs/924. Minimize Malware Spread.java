// In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1.

// Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes 
//is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be 
//infected in this manner.

// Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops.

// We will remove one node from the initial list.  Return the node that if removed, would minimize M(initial).  If multiple nodes 
//could be removed to minimize M(initial), return such a node with the smallest index.

// Note that if a node was removed from the initial list of infected nodes, it may still be infected later as a result of the malware 
//spread.

 

// Example 1:

// Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
// Output: 0
// Example 2:

// Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
// Output: 0
// Example 3:

// Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
// Output: 1
class Solution {

    public int minMalwareSpread(int[][] graph, int[] initial) {
        
        int nodes = graph.length;
        DSU dsu = new DSU(nodes);
        
        for(int i=0;i<nodes-1;i++)
            for(int j=i+1;j<nodes;j++){
                if(graph[i][j]==1)
                    dsu.union(i, j);
            }
        HashMap<Integer, Integer> map = new HashMap<>();
        for(int i:initial){
            int x = dsu.find(i);
            map.put(x, map.getOrDefault(x,0)+1);
        }
        
        int componentsize=0;
        
        Arrays.sort(initial);
        int result=initial[0];
        
        // System.out.println(map);
        // System.out.println(Arrays.toString(dsu.arr));
        // System.out.println(Arrays.toString(dsu.count));
        
        for(int i:initial){
            int x = dsu.find(i);
            if(map.get(x)==1 && dsu.count[x]>componentsize){
                result = i;
                componentsize = dsu.count[x];
            }
        }
        return result;
    }
    
    class DSU{

        int[] arr;
        int[] count;
        
        DSU(int n){
            arr = new int[n];
            count = new int[n];
            
            for(int i=0;i<n;i++){
                arr[i]=i;   
            }
            Arrays.fill(count, 1);
        }
        
        void union(int i, int j){
            int x = find(i);
            int y = find(j);
            if(x==y) return;
            arr[x]=y;
            count[y]+=count[x];
        }
        
        int find(int i){
            if(arr[i]!=i)
                arr[i]=find(arr[i]);
            return arr[i];
        }
        
    }
}
